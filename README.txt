********************************************************************************
CS525: Advanced Database Organization
Fall 2021 | Group 22
Isa Muradli           (imuradli@hawk.iit.edu)       (Section 01)
Andrew Petravicius    (apetravicius@hawk.iit.edu)   (Section 01)
Christopher Sherman   (csherman1@hawk.iit.edu)      (Section 02)
********************************************************************************

1. Scripts
********************************************************************************

To build and run the given test executable "test_assign1" using
"test_assign1_1.c", use the following commands:

$ make
$ ./test_assign1_1.c

To build and run the original test file created by CS 525 Fall 2021 Group 22,
use the following commands:

$ make my_test
$ ./my_test1.out

To remove all files generated by building and running the test programs, use
the following command:

$ make clean

To run build all test files, run all tests, and clean up the directory all in
one command, use the following

$ make all


2. Design
********************************************************************************

In this section, we briefly describe the design of our storage manager.


2.1. Management Info (SM_FileHandle.mgmtInfo)
**************************************************

In the given data structure for a file handle, we were given a void pointer.
This provided the freedom to add any more useful information we may need for
our storage manager. The one useful piece of information not already given
space in the file handle was a pointer to the FILE object used buy C file
handling (fopen, fclose, fread, fwrite, etc.). However, we made a struct for
any additional information we may want stored by a file handle. This will allow
for a more scalability. If we decide we need more information stored in the
file handle in the future, we can easily add it to this data structure without
much need for modifying existing code.

```
typedef struct SM_MgmtInfo {
  FILE* file;
} SM_MgmtInfo;
```


2.2. RC createPageFile (char *fileName)
**************************************************

This function creates a new page file using fileName. If a file by that name
already exists, we delete that file and make a new one. We populate a string
that is PAGE_SIZE in length and set each character (byte) in this string to the
null character ('\0') before writing this string to the page file.


2.3. RC openPageFile (char *fileName, SM_FileHandle *fHandle)
**************************************************

This function opens a page file if one by `fileName` exists. If not,
the function returns response code RC_FILE_NOT_FOUND. When found, we use
the `fstat() function to get the file size. The file size is divided by
`PAGE_SIZE` to get the total number of pages in the file. This is stored in
`fHandle`. The current page position `curPagePos` is set to 0. Our management
information structure is allocated heap memory with `malloc()` and the FILE
object pointer returned by `fopen()` is saved in that structure.


2.4. RC closePageFile (SM_FileHandle *fHandle)
**************************************************

In addition to calling `fclose()` to close the file descriptor in the OS,
we call `free()` on our management information structure `fHandle->mgmtInfo`
because we used `malloc()` previously to allocate heap memory for this struct.


2.5. RC destroyPageFile (char *fileName)
**************************************************

Use `remove()` to delete the given file. If this fails, we return an
`RC_FILE_NOT_FOUND` error code.


2.6. RC readBlock (int pageNum, SM_FileHandle *fHandle, SM_PageHandle memPage)
**************************************************

First, we check to make sure the desired page to read is less than the total
number of pages stored in the file handle and greater than 0. If this is true,
we then extract the FILE object pointer stored in the management information
structure. Next, we set the offset to the desired byte in the pagefile,
calculated by the formula BYTE = pageNum * PAGE_SIZE. We use `SEEK_SET` as a
`whence` value for fseek, because we want to set the offset to the provided
number of bytes. Once we are at the desired offset in the page file, we read
one PAGE_SIZE into memory. All thats left is to record the `pageNum` just
read into the `curPagePos` of the file handle.


2.7. All Other Read Functions
**************************************************

All of the other "read" functions defined in `storage_mgr.c` are trivial special
cases of the `readBlock()` function. All that differs is how the `pageNum`
argument is calculated.


2.8. int getBlockPos (SM_FileHandle *fHandle)
**************************************************

This function trivially gets the curPagePos stored in the file handle.


2.9. RC writeBlock (int pageNum, SM_FileHandle *fHandle, SM_PageHandle memPage)
**************************************************

This writes the page stored in memory `memPage` to the page file at pageNum.
The `writeBlock` function operates almost identically to `readBlock()` but
(obviously) swaps `fread()` for `fwrite()`. There is also no error checking
for RC_READ_NON_EXISTING_PAGE because that wouldn't make sense.


2.10. RC writeCurrentBlock (SM_FileHandle *fHandle, SM_PageHandle memPage)
**************************************************

A trivial special case of `writeBlock` where we use `fHandle->curPagePos` as
the `pageNum` argument.


2.11. RC ensureCapacity (int numberOfPages, SM_FileHandle *fHandle)
*************************************************

Ensure capacity can be ready semantically as "make sure that this pageFile can
store this many pages". First, we compare the number of pages stored in the
file handle. The the requested `numberOfPages` is greater than that value stored
in the file handle, we extend the file by seeking to the end and using
`fwrite()` to write more null characters to the end. We make one page handle
and use a loop to write as many pages as needed (the difference of numberOfPages
and `fHandle->totalNumPages`)


2.12 RC appendEmptyBlock (SM_FileHandle *fHandle)
**************************************************

This function extends the page file by one page. This is a special case of
ensureCapacity where the `numberOfPages` argument is one more than
`totalNumPages`.